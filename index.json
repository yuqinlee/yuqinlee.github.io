[{"categories":["dev-env"],"content":"\r","date":"2024-06-22","objectID":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/:0:0","series":null,"tags":["docker","wsl","arch"],"title":"Windows 安装 Docker、wsl 等","uri":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/#"},{"categories":["dev-env"],"content":"\r安装 WSL——Archlinux控制面板找到 启用或关闭windows功能 勾选 Hyper-V 和 适用于 Linux 的 Windows 子系统（只用勾选后者实际就能WSL安装，如果需要使用原来的 Hyper-V 方式安装 Docker 才需要开启前者，这里直接都打开了），重启系统，执行 wsl --update 更新 安装 Archlinux 作为子系统 从 https://github.com/yuk7/ArchWSL/releases 下载压缩包 解压到指定目录 双击解压好的 Arch.exe 进行安装，这个 .exe 的名字 就是要创建的 WSL 实例的名字，改不同的名字就能创建多个 Arch WSL。 常用命令 bash wsl --list # 查看当前 wsl 中有的子系统 wsl --update # 下载或者更新 wsl --shutdown # 重新启动 wsl -d Arch # 进入名为 Arch 的子系统\r官网文档：https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands 配置用户 bash passwd root useradd -m -G wheel -s /bin/bash uchin passwd uchin\r退出ArchLinux，进入刚刚安装ArchLinux的目录（例如D:\\vm\\archlinux），将默认用户改为非root用户： bash exit # 退出archlinux，之后你会回到Windows cd D:\\WSL\\Arch .\\Arch.exe config --default-user uchin\r配置hostname 参考：WSL设置hostname，不修改Windows主机名 默认的 /etc/ws.conf 如下 bash [uchin@DESKTOP-UCHIN ~]$ cat /etc/wsl.conf [boot] systemd=true [automount] enabled = true options = \"metadata\" mountFsTab = true\r该文件详细配置参考文档：https://learn.microsoft.com/zh-cn/windows/wsl/wsl-config bash [uchin@DESKTOP-UCHIN ~]$ cat /etc/wsl.conf [boot] systemd=true [automount] enabled = true options = \"metadata\" mountFsTab = true # 设置 wsl 自己的 hostname [network] generateResolvConf = true hostname = uchin-arch # 禁用 windows 环境变量 [interop] enabled = false appendWindowsPath = false\r","date":"2024-06-22","objectID":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/:1:0","series":null,"tags":["docker","wsl","arch"],"title":"Windows 安装 Docker、wsl 等","uri":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/#安装-wslarchlinux"},{"categories":["dev-env"],"content":"\r安装 docker","date":"2024-06-22","objectID":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/:2:0","series":null,"tags":["docker","wsl","arch"],"title":"Windows 安装 Docker、wsl 等","uri":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/#安装-docker"},{"categories":["dev-env"],"content":"\r安装这里使用 WSL2 的方式安装 Windows Docker WSL 对比 Hyper-V 体验更好，可以不考虑原来 Hyper-V 的方式了 运行 wsl --update，如果之前没更新会更新WSL，然后下载 Windows Docker https://www.docker.com/products/docker-desktop/ 安装时勾选 WSL2 安装即可安装完成 ","date":"2024-06-22","objectID":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/:2:1","series":null,"tags":["docker","wsl","arch"],"title":"Windows 安装 Docker、wsl 等","uri":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/#安装"},{"categories":["dev-env"],"content":"\r修改镜像位置默认安装 docker 后镜像存放路径为 C:\\Users\\uchin\\AppData\\Local\\Docker\\wsl 当镜像过多后会大量占用 C 盘 Docker Desktop WSL2 默认会安装2个子系统，使用命令wsl -l -v –all查看 bash C:\\Users\\uchin\u003ewsl -l -v --all NAME STATE VERSION * Arch Running 2 docker-desktop-data Running 2 docker-desktop Running 2\r两个子系统分别为 docker-desktop-data 与 docker-desktop docker-desktop-data 与 docker-desktop 前者存放数据，后者存放程序 bash # 1. 退出Docker Desktop # 2. 关闭 WSL wsl --shutdown # 3. 将子系统导出为 tar 文件 wsl --export docker-desktop D:\\WSL\\docker\\docker-desktop.tar wsl --export docker-desktop-data D:\\WSL\\docker\\docker-desktop-data.tar # 4. 注销子系统 wsl --unregister docker-desktop wsl --unregister docker-desktop-data # 5. 使用新路径导入子系统 wsl --import docker-desktop D:\\WSL\\docker\\docker-desktop D:\\WSL\\docker\\docker-desktop.tar --version 2 wsl --import docker-desktop-data D:\\WSL\\docker\\docker-desktop-data D:\\WSL\\docker\\docker-desktop-data.tar --version 2\r参考： √ Arch WSL 安装 1 √ Arch WSL 安装 2 × Arch WSL appx 安装方式 √ windows docker 安装 √ Docker Desktop(WSL2)修改镜像存储位置 √ ls 命令输出的颜色 √ 系统配置bash shell字体颜色 Linux PS1 的常用配置 √ 通过 VcXsrv 在 WSL2 上使用图形化界面 √ 使用 WSL2 + X11 转发 - 在 Windows10 中打造 GNU/Linux 学习生产环境 ","date":"2024-06-22","objectID":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/:3:0","series":null,"tags":["docker","wsl","arch"],"title":"Windows 安装 Docker、wsl 等","uri":"/windows-%E5%AE%89%E8%A3%85-dockerwsl-%E7%AD%89/#修改镜像位置"},{"categories":["linux"],"content":"\rlinux重定向可以将命令的输出或输入重新定向到其他位置或文件，以实现对输出输入的控制。默认情况下命令的输出通常为终端，如果想将输出转移到文件或其他位置，这时候就需要重定向。 文件描述符：一个命令通常都会打开三个文件，默认使用文件描述符0,1,2来指代这个三个文件 bash stdin 0 标准输入流 （键盘） stdout 1 标准输出流 （终端） stderr 2 标准错误输出流 （终端）\r以上标准输出和输入均在终端中进行，而重定向符 \u003e、\u003e\u003e 就是将其输出对象进行改变 shell 中常见重定向形式如下： bash \u003e file // 标准输出重定向到文件（覆盖） \u003e\u003e file // 标准输出重定向到文件（追加） 2\u003e file // 标准错误重定向到文件（覆盖） 2\u003e\u003e file // 标准错误重定向到文件（追加） 2\u003e /dev/null // 标准错误重定向到回收站 \u0026\u003e file // 标准输出和标准错误重定向到文件（覆盖） \u003e\u003e file 2\u003e\u00261 // 标准输出和标准错误重定向到文件（追加）\r默认的重定向为标准输出重定向，即 \u003e file 等价于 1\u003e file \u0026\u003e file 等价于 1\u003e file 2\u003e\u00261 ，这里的 \u00261 指的是标准输出 1 当格式为 \u003e\u003e file 2\u003e\u00261 不代表 标准输出追加而标准错误输出覆盖！ Linux ：输入/输出重定向 \u003e, 1\u003e, 2\u003e, \u0026\u003e, » , « linux 中的输入输出重定向（b 站） ","date":"2022-09-30","objectID":"/linux-%E9%87%8D%E5%AE%9A%E5%90%91/:0:0","series":null,"tags":["linux","redirection","重定向"],"title":"Linux 重定向","uri":"/linux-%E9%87%8D%E5%AE%9A%E5%90%91/#"},{"categories":["base-tool"],"content":"\r","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#"},{"categories":["base-tool"],"content":"\r1. git 配置","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:0","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#1-git-配置"},{"categories":["base-tool"],"content":"\r1.1 git 三级配置 System： /etc/gitconfig，Msys64 底下的 etc Global： ~/.gitconfig，Msys64 底下的 home/[UserName]/w为 ~ 工程目录： .git/gitconfig 作用域依次减小，优先级依次升高 ps：不是安装 Msys64 而是Window 版的 git 在window用户家目录下会有文件.gitconfig bash git config --system --list # 查看系统配置 git config --global --list # 查看全局配置 git config --list # 查看所有配置 git config -l # 同上简写 git config --system -e # 直接打开系统配置 git config --global -e # 直接打开全局配置 git config -e # 直接打开项目配置\r注：git config --list 查看的是当前项目所有的配置（综合系统配置与全局配置和项目配置），不是仅仅查看的 .git 目录下的配置 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:1","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#11-git-三级配置"},{"categories":["base-tool"],"content":"\r1.2 修改 git 配置通过上述命令查看用户名是否设置完成，没有需要进行设置 bash # 设置用户签名 git config --global user.name \"userName\" git config --global user.email \"userEmail\"\r用户名和邮件是必须要配置的！ 无论采用用户名+密码验证方式的 http，还是采用密钥验证的 ssh，在和远程仓库关联时均只是在做权限验证，即是否能往该远程库推送。但具体提交的修改需要记录是谁做的，因此 git 系统中需要配置用户名与邮件地址来在远程仓库记录下这些操作是由谁来完成的。 具体参考对给git配置邮箱和用户名的理解 除了设置全局签名，使用 git config user.name \"userName\" 来设置当前项目的签名也可以。 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:2","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#12-修改-git-配置"},{"categories":["base-tool"],"content":"\r2. git 理论 工作区=》写代码 临时存储=》暂存区 历史版本=》本地库 工作区=》git add 添加到暂存区=》git commit本地库 只有在git commit进行提交到本地库后才有版本控制 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:0","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#2-git-理论"},{"categories":["base-tool"],"content":"\r3. 项目中常用命令","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:0","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#3-项目中常用命令"},{"categories":["base-tool"],"content":"\r3.1 初始化、提交等\rbash git init # 初始化本地库\rbash git status # 查看本地库状态\r查看文件有没有被修改、追踪 bash git add fileName # 添加到缓存区 git add . # 添加当前目录所有文件进行追踪 git rm --cached fileName # 删除缓存区的文件\r没有被追踪文件/文件夹，存在工作区，通过 add 使其添加到缓存区 git 追踪的文件发生修改是绿色,没被追踪的文件发生修改是红色 通过 add 添加至缓冲区的文件能通过 git rm --cached 从缓冲区中删除，不再追踪。命令删除的是缓存区的文件，工作区的文件依旧存在的 ps：windows端git的bash里使用vim编辑文件后 add 命令会将LF转换成CRLF，但是msys2的不会 bash git diff # 查看具体修改地方\rbash git commit -m \"日志信息\" fileName # 提交本地库\rbash git reflog # 查看版本信息\rbash git log\rbash # 版本穿梭 git reset --hard 版本号\r示例如下： txt eg. C:\\Users\\yuqin\\Desktop\\git_demo\u003egit reflog 5341b98 (HEAD -\u003e master) HEAD@{0}: commit: second commit 326787f HEAD@{1}: commit (initial): first commit C:\\Users\\yuqin\\Desktop\\git_demo\u003egit reset --hard 326787f HEAD is now at 326787f first commit C:\\Users\\yuqin\\Desktop\\git_demo\u003egit reflog 326787f (HEAD -\u003e master) HEAD@{0}: reset: moving to 326787f 5341b98 HEAD@{1}: commit: second commit 326787f (HEAD -\u003e master) HEAD@{2}: commit (initial): first commit\r忽略特殊文件 txt # .gitignore # 忽略所有 .a 结尾的文件 *.a # 但 lib.a 除外 !lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO /TODO # 忽略 build/ 目录下的所有文件 build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt doc/*.txt # ignore all .txt files in the doc/ directory doc/**/*.txt ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:1","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#31-初始化提交等"},{"categories":["base-tool"],"content":"\r分支相关\rbash git branch # 查看分支 git branch -r # 查看远程分支 git branch -a # 查看所有分支（包括远程） git branch \u003cname\u003e # 创建分支 git branch -d \u003cname\u003e # 删除分支 git checkout \u003cname\u003e # 切换分支 git branch -b \u003cname\u003e # 创建并切换 git switch \u003cname\u003e # 切换分支 git switch -c \u003cname\u003e # 创建并切换 git merge \u003cname\u003e # 合并分支\r例如，在 master 分支中使用 git merge dev 命令，则会将 dev 分支的更新内容合并至 master 分支。 在 idea 中，直接从右下角找到 dev 分支，选择 Merge dev into master 即可。 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:2","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#分支相关"},{"categories":["base-tool"],"content":"\r3.2 克隆远程库\rbash # https 协议下载 git clone https://gitee.com/yuqinlee/test.git # ssh 协议下载 git clone git@gitee.com:liaoxuefeng/learngit.git # 本地没有项目，直接拉取指定分支 git clone -b dev git@gitee.com:liaoxuefeng/learngit.git # 本地已经有项目 git fetch --all # 先更新 git checkout -b dev origin/dev # 在拉取\r使用 git clone 命令下载远程库后，会自带版本信息 clone、fetch、pull区别： clone：远程克隆仓库，带版本控制 fetch：从远程获取最新版本到本地，不会自动merge pull：从远程获取最新版本并merge到本地仓库 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:3","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#32-克隆远程库"},{"categories":["base-tool"],"content":"\r3.3 关联远程库\rbash # http 协议关联 git remote add origin https://gitee.com/yuqinlee/test.git # ssh 协议关联 git remote add origin git@gitee.com:liaoxuefeng/learngit.git\r取消关联远程仓库 bash git remote remove origin\r将本地分支关联到远程分支 bash git branch --set-upstream-to=origin/develop develop\r","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:4","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#33-关联远程库"},{"categories":["base-tool"],"content":"\r3.4 同步\rbash git push -u origin \"master\" # 推送\r远程关联仓库（gitee 示例） Git 全局设置: bash git config --global user.name \"yuqinlee\" git config --global user.email \"yuqin.lee@outlook.com\"\r创建 git 仓库: bash mkdir test cd test git init touch README.md git add README.md git commit -m \"first commit\" # git remote add origin https://gitee.com/yuqinlee/test.git git remote add origin git@gitee.com:liaoxuefeng/learngit.git git push -u origin \"master\" # 指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置dev和 origin/dev 的链接 git branch --set-upstream-to=origin/dev dev\r已有仓库? bash cd existing_git_repo git remote add origin https://gitee.com/yuqinlee/test.git git push -u origin \"master\"\r参考 Git 原理入门 - 阮一峰的网络日志 (ruanyifeng.com) 5.git添加远程仓库,再克隆到本地,然后做分支管理 廖雪峰 git 教程 git clone、git pull和git fetch的用法及区别 对给git配置邮箱和用户名的理解 https://www.bilibili.com/video/BV1FE411P7B3?spm_id_from=..search-card.all.click git 学习记录—— git 中的仓库、文件状态等概念介绍 lh-常用Git命令总结 代码同时更新到Gitee和github 注：使用Msys2的git vscode会有问题 ","date":"2022-01-24","objectID":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:5","series":null,"tags":["git"],"title":"Git 使用小结","uri":"/git-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/#34-同步"},{"categories":["distributed"],"content":"\r2020-11-04 https://www.bilibili.com/video/av37065233 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:0:0","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#"},{"categories":["distributed"],"content":"\r一、BTC-密码学原理","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:0","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#一btc-密码学原理"},{"categories":["distributed"],"content":"\r1. Hash\r性质1 collision resistance密文m H(m)经过hash函数处理之后得到一个hash值，很难在修改m后再进行hash运算还是原来的值，尽管存在hash碰撞 没有证明那个hash函数是不存在collision resistance的！！但是有函数是被验证是能够人为找出碰撞的，如MD5 性质2 hidinghiding：hash函数的计算是单向且不可逆的，即给定x，可以算出其hash值$H(x)$ , $x-\u003eH(x)$但是没办法从$H(x)$反推出$x$ hiding成立的前提是输入空间足够大(不然直接暴力遍历出原文),并且输入的取值比较均匀,各种取值差不多 hiding与collision resistance结合起来,实现 digital commitment(digital equivalent of a sealed envelope) 例如,呀进行股市的预测,需提前给出预测,但是又不能将结果直接公布,因为这个预测会对结果产生影响,所以,可以先将预测进行hash,得到一个hash值,由于性质1与性质2,在第二天结果知晓后,公布预测内容并计算hash值,对比之前公布的hash值,相同则预测正确 实际操作中,为使输入的空间足够大,可以$H(x||nonce)$,即在输入内容后增加一个随机数(nonce) 性质3 puzzle friendlypuzzle friendly:hash值的计算事先是不可预测的,即如果想获得一个区间范围内的hash值,那只能一个一个试 例如,想要获得一个经过hash运算后，256位的hash值是形如\"00……00xxxxx\"前k位都是\"0\"的原文，那只能一个一个试，而没有方法实现知道。在挖矿中，$nonce$在$block\\quad header$中,是可以自己设置的,挖矿过程就是找到适合的$nonce$使得满足以下式子: $$ H(block\\quad header)\\leq target $$ $H(block\\quad header)$要落在指定的$target\\quad space$中,只有经过大量的尝试,才能证明其中的\"$proof\\quad of\\quad work$\",在这个过程中,“挖矿\"是很难的,但是去验证是很容易的,这个性质叫**“difficult to solve,but easy to verify”** 在比特币中使用的hash函数是$SHA-256(Secure Hash Algorithm)$,满足上述三个性质 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#1-hash"},{"categories":["distributed"],"content":"\r1. Hash\r性质1 collision resistance密文m H(m)经过hash函数处理之后得到一个hash值，很难在修改m后再进行hash运算还是原来的值，尽管存在hash碰撞 没有证明那个hash函数是不存在collision resistance的！！但是有函数是被验证是能够人为找出碰撞的，如MD5 性质2 hidinghiding：hash函数的计算是单向且不可逆的，即给定x，可以算出其hash值$H(x)$ , $x-\u003eH(x)$但是没办法从$H(x)$反推出$x$ hiding成立的前提是输入空间足够大(不然直接暴力遍历出原文),并且输入的取值比较均匀,各种取值差不多 hiding与collision resistance结合起来,实现 digital commitment(digital equivalent of a sealed envelope) 例如,呀进行股市的预测,需提前给出预测,但是又不能将结果直接公布,因为这个预测会对结果产生影响,所以,可以先将预测进行hash,得到一个hash值,由于性质1与性质2,在第二天结果知晓后,公布预测内容并计算hash值,对比之前公布的hash值,相同则预测正确 实际操作中,为使输入的空间足够大,可以$H(x||nonce)$,即在输入内容后增加一个随机数(nonce) 性质3 puzzle friendlypuzzle friendly:hash值的计算事先是不可预测的,即如果想获得一个区间范围内的hash值,那只能一个一个试 例如,想要获得一个经过hash运算后，256位的hash值是形如\"00……00xxxxx\"前k位都是\"0\"的原文，那只能一个一个试，而没有方法实现知道。在挖矿中，$nonce$在$block\\quad header$中,是可以自己设置的,挖矿过程就是找到适合的$nonce$使得满足以下式子: $$ H(block\\quad header)\\leq target $$ $H(block\\quad header)$要落在指定的$target\\quad space$中,只有经过大量的尝试,才能证明其中的\"$proof\\quad of\\quad work$\",在这个过程中,“挖矿\"是很难的,但是去验证是很容易的,这个性质叫**“difficult to solve,but easy to verify”** 在比特币中使用的hash函数是$SHA-256(Secure Hash Algorithm)$,满足上述三个性质 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#性质1-collision-resistance"},{"categories":["distributed"],"content":"\r1. Hash\r性质1 collision resistance密文m H(m)经过hash函数处理之后得到一个hash值，很难在修改m后再进行hash运算还是原来的值，尽管存在hash碰撞 没有证明那个hash函数是不存在collision resistance的！！但是有函数是被验证是能够人为找出碰撞的，如MD5 性质2 hidinghiding：hash函数的计算是单向且不可逆的，即给定x，可以算出其hash值$H(x)$ , $x-\u003eH(x)$但是没办法从$H(x)$反推出$x$ hiding成立的前提是输入空间足够大(不然直接暴力遍历出原文),并且输入的取值比较均匀,各种取值差不多 hiding与collision resistance结合起来,实现 digital commitment(digital equivalent of a sealed envelope) 例如,呀进行股市的预测,需提前给出预测,但是又不能将结果直接公布,因为这个预测会对结果产生影响,所以,可以先将预测进行hash,得到一个hash值,由于性质1与性质2,在第二天结果知晓后,公布预测内容并计算hash值,对比之前公布的hash值,相同则预测正确 实际操作中,为使输入的空间足够大,可以$H(x||nonce)$,即在输入内容后增加一个随机数(nonce) 性质3 puzzle friendlypuzzle friendly:hash值的计算事先是不可预测的,即如果想获得一个区间范围内的hash值,那只能一个一个试 例如,想要获得一个经过hash运算后，256位的hash值是形如\"00……00xxxxx\"前k位都是\"0\"的原文，那只能一个一个试，而没有方法实现知道。在挖矿中，$nonce$在$block\\quad header$中,是可以自己设置的,挖矿过程就是找到适合的$nonce$使得满足以下式子: $$ H(block\\quad header)\\leq target $$ $H(block\\quad header)$要落在指定的$target\\quad space$中,只有经过大量的尝试,才能证明其中的\"$proof\\quad of\\quad work$\",在这个过程中,“挖矿\"是很难的,但是去验证是很容易的,这个性质叫**“difficult to solve,but easy to verify”** 在比特币中使用的hash函数是$SHA-256(Secure Hash Algorithm)$,满足上述三个性质 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#性质2-hiding"},{"categories":["distributed"],"content":"\r1. Hash\r性质1 collision resistance密文m H(m)经过hash函数处理之后得到一个hash值，很难在修改m后再进行hash运算还是原来的值，尽管存在hash碰撞 没有证明那个hash函数是不存在collision resistance的！！但是有函数是被验证是能够人为找出碰撞的，如MD5 性质2 hidinghiding：hash函数的计算是单向且不可逆的，即给定x，可以算出其hash值$H(x)$ , $x-\u003eH(x)$但是没办法从$H(x)$反推出$x$ hiding成立的前提是输入空间足够大(不然直接暴力遍历出原文),并且输入的取值比较均匀,各种取值差不多 hiding与collision resistance结合起来,实现 digital commitment(digital equivalent of a sealed envelope) 例如,呀进行股市的预测,需提前给出预测,但是又不能将结果直接公布,因为这个预测会对结果产生影响,所以,可以先将预测进行hash,得到一个hash值,由于性质1与性质2,在第二天结果知晓后,公布预测内容并计算hash值,对比之前公布的hash值,相同则预测正确 实际操作中,为使输入的空间足够大,可以$H(x||nonce)$,即在输入内容后增加一个随机数(nonce) 性质3 puzzle friendlypuzzle friendly:hash值的计算事先是不可预测的,即如果想获得一个区间范围内的hash值,那只能一个一个试 例如,想要获得一个经过hash运算后，256位的hash值是形如\"00……00xxxxx\"前k位都是\"0\"的原文，那只能一个一个试，而没有方法实现知道。在挖矿中，$nonce$在$block\\quad header$中,是可以自己设置的,挖矿过程就是找到适合的$nonce$使得满足以下式子: $$ H(block\\quad header)\\leq target $$ $H(block\\quad header)$要落在指定的$target\\quad space$中,只有经过大量的尝试,才能证明其中的\"$proof\\quad of\\quad work$\",在这个过程中,“挖矿\"是很难的,但是去验证是很容易的,这个性质叫**“difficult to solve,but easy to verify”** 在比特币中使用的hash函数是$SHA-256(Secure Hash Algorithm)$,满足上述三个性质 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#性质3-puzzle-friendly"},{"categories":["distributed"],"content":"\r2. 签名$asymmetric\\quad encryption\\quad algorithm(非对称加密)$ 在现实中开户需要到银行进行相关手续，但是比特币开户只需要在本地创建一对公钥与私钥即可$(public\\quad key ,private\\quad key)$,知道公钥就相当于知道银行账号,其他人可以往里转账,而私钥就好比是账户的口令,能将账户中的\"钱\"取出来。比特币是不加密的加密货币，这里公私钥是为了进行签名。 会不会两人生成的公私钥对是相同的？答：可能性微乎其微 这里生成公私钥要求有一个$a\\quad good\\quad source\\quad of\\quad randomness$，如果随机源选择不好的话就有可能两个人的公私钥相同了；在比特币中，除了生成公私钥对时需要一个好的随机源，在每一次加密的过程中都需要有好的随机源，不然可能泄露私钥 比特币中一般是先对message进行hash，然后再对hash值进行签名！！ 区块链技术与应用——BTC密码学原理 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:1:2","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#2-签名"},{"categories":["distributed"],"content":"\r二、BTC-数据结构","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:2:0","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#二btc-数据结构"},{"categories":["distributed"],"content":"\rhash pointer、区块链普通指针是存储一个结构体的地址值，而hash指针除了存储地址值外还存储hash值，这样一来可以找到该结构体的位置，二来可以知道该结构体是否被改变，一般使用$H()$表示 比特币中区块与普通的区块的一个区别就是使用hash指针代替了普通指针 $Block\\quad chain\\quad is\\quad a\\quad linked\\quad list\\quad using\\quad hash\\quad pointers$ 后面一个hash值是将前面区块$block\\quad header$整个取hash，包括其中的hash function，以此实现了 tamper-evident log，这样如果前一个区块中的内容发生改变，那么后面的hash值也会发生改变，依次类推，后面所有的区块内容都会发生改变，所以只要记住最后的hash值就可以检测出整个区块链中任何部位的修改，这也是和普通区块的不同。 本地不必存储所有的区块，在需要使用前面的区块时向其他节点要即可，验证真伪只需要将前面的hash值进行对比就可。 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:2:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#hash-pointer区块链"},{"categories":["distributed"],"content":"\rMerkel tree 两个data blocks的hash pointer放在父节点，这两个hash pointer组合再取hash值，构成整个父节点，两个父节点的的hash pointer再放在更上一层中，…… binary tree与Merkel tree的区别 merkel tree使用hash指针代替了原有指针 只要记录root hash值，就能检测出对树中任何部位的修改 每个data block都是一个“交易” 比特币中各个区块之间用hash 指针连接在一起，每个区块所包含的交易是组织成一个Merkel tree的形式 每个区块分为$block\\quad header$和$block\\quad body$，在$block\\quad header$中有根hash值，而没有交易的具体内容，$block\\quad body$中是有交易列表的 merkel tree的作用：提供Merkel proof，示意图如下： 轻节点向全节点进行一个Merkel proof的请求，全节点向轻节点发送红色的H() 轻节点在本地根据待证明tx可以计算出其上一个绿色H()，而红色的H()是向全节点请求能得到的，因此和红色H()结合能算出再上一层的绿色H()，……最后能算出一个根hash值 此时与轻节点所保存的根hash值进行比较就可以验证是否待证明的tx交易在整个区块链中 以上证明称为$proof\\quad of\\quad membership$或$proof\\quad of\\quad inclusion$，其事件复杂度为$O(log(n))$,如果是证明$proof\\quad of\\quad no-membership$,其中一个方式是将整棵Merkel tree传回来，验证每一层的hash值都是正确的，则说明这树中只有这些叶节点，而没有待验证的此时复杂度为$O(n)$,如果没有对叶节点进行排序等操作，是没有更好的办法的，但是将tx按照交易的hash值进行排序，就能以$O(log(n))$的代价进行验证了，此时这棵树叫$sorted\\quad merkel\\quad tree$,在比特币中是没有这种需求的！ 没有环的数据结构中，hash pointer基本都可以代替普通指针，但是有环的是不行的 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:2:2","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#merkel-tree"},{"categories":["distributed"],"content":"\r三、BTC-协议前言 数字货币方案1 假设央行发行数字货币，只采用非对称密码，央行保存私钥，并用私钥进行数字签名，这样发行出来的货币存在的问题：“double spending attack”，即可以将央行发行的数字货币进行复制，从而进行多次支付！这也是数字货币面临的主要挑战。 数字货币方案2 在之前的基础上为每个数字货币添加一个编号，央行对编号的所有者进行记录，同时在完成支付之后更改编号所有者。这样就能防范“double spending attack ”。 这套方案可行，但每笔交易都经过央行，过于繁琐，这是一种中心化的方案。 简单区块链示意 上图中有两种hash指针，一种是区块链之间的连接的hash指针(橙色)，另一种是指向前面某个交易的(绿色) 比特币系统中每个交易都包含输入和输出两个部分: 输入：①说明币的来源；②A的公钥是什么 输出：给出收款人的公钥的hash 为什么要记录来源？①证明这个钱不是凭空捏造的；②防止double spending attack 例如上图中：B已经将钱转给C和D了，现在出现F，B要将钱再次转给F 别的节点收到交易后，从B转向F的交易向前查询，当查到B转给C与D时就会出生问题，B在转给C与D的这次交易中就已将5个币花了出去，即说明B转给F的交易是不合法的！！ 上述转账中，A转账给B，A需要的信息有： A的签名 B的地址（比特币中收款的地址通过公钥推算出来，公钥取hash经过一些转换得到） 比特币系统是不会提供查询某个人的地址的服务的，想要知道别人的地址，需要通过其他渠道，例如在某支持比特币的购物网站上，收款人可以贴出自己的地址/公钥。 上述转账中B、乃至所有的节点还需要知道A的公钥，因为B要知道支付人的信息，才能知道这笔交易的钱是从哪来的，同时A支付这一过程中A进行了签名，要验证签名就需要A的公钥（签名是私钥签，公钥验证）。A在交易的输入中就会说明A的公钥是什么。 问题：自己宣称公钥是否有漏洞？ 如果存在B的同伙$B’$,这时候伪造一个A到B的转账交易，$B’$用自己的公钥在输入中说是A的公钥，用自己的私钥进行签名，当别的节点用假造的公钥去验证交易的合法性，就会盗走A账户的钱？ 解决方式： 在Create Coin过程的输出中包含着A的公钥的hash，在交易A向B转账时，A的公钥要和之前的输出过程的hash对得上才行 示意图中每个区块包含着一个交易，但实际过程中每个区块中包含着许多交易，这些交易组装成Merkel Tree，每个区块分为$Block\\quad header$与$Block\\quad body$两个部分。 $Block\\quad header$包含着区块中的宏观信息: 使用的是比特币哪个版本的协议(version) 执行前一个区块的指针(hash of previous block header) 前一个区块的hash只算的是$block\\quad header$！！ 只有block header才有hash指针串联起来，每次取hash都是将块头进行取hash 因为Merkel root hash就能保证Block body中的交易列表是没有办法进行改变的。（因为要是改变了那header的hash值就会发生变化） 整个Merkel tree的根hash值(Merkel root hash) 难度目标阈值(target) 随机数(nonce) $$ H(block\\quad header)\\leq target $$ $block\\quad header$的hash值要小于target ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:3:0","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#三btc-协议"},{"categories":["distributed"],"content":"\r关于full node（全节点）与light node（轻节点）full node：也称fully validating node，保存全部信息 light node：只保存block header的信息，一般是无法独立验证交易的合法性的。轻节点知识利用区块链的信息进行一些查询等操作。 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:3:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#关于full-node全节点与light-node轻节点"},{"categories":["distributed"],"content":"\r比特币中的共识协议（Consensus in BitCoin） 账本的内容要取得分布式共识 distributed consensus FLP impossibility result： 在异步式系统（网络传输时延没有上限）中，只有一个成员有问题，也不可能取得共识 CAP Theorem：CAP三个性质中最多只能满足两个（见分布式系统） 共识协议要解决的问题：有些节点可能是有恶意的，这里假设系统中大多数节点是没有恶意的，有恶意的只是少数 **假想：**投票机制，某个节点提出一个候选区块，根据收到的交易信息，选择那些交易是合法的，将这些交易打包到区块里，将这个候选区块发布给所有节点，每个节点收到这个区块后检查一下是不是每个交易都是合法的，都合法就投赞成票，有一个交易是非法的就投反对票，赞成过半就写入区块链中 存在的问题： 提出候选区块的节点恶意加入非法区块到候选区块，并不断提交这种带非法交易的候选区块，造成一直投票却无法写入区块链 无法保证每个节点都投票 效率问题、网络还有延迟 比特币系统中，投票权问题无法确定，只要恶意产生足够多账户，超过半数，就可操作结果 （$sybil\\quad attack$） 在比特币中也是进行“投票”，但是是利用算力进行投票，每个节点都可以在本地组装出候选区块，将其认为合法的交易放到这个区块中，然后尝试各种nonce值，如果某个节点找到了nonce，使得$H(block\\quad header)\\leq target$,则该节点获得了记账权，即能往账本中写入下一个区块的权利。其他节点则检查是否符合要求。 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:3:2","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#比特币中的共识协议consensus-in-bitcoin"},{"categories":["distributed"],"content":"\r最长合法链下图中，区块1为C转账A，区块3为A转B，区块5为A再次转给自己，首先，这没有构成$double\\quad spending\\quad attack$,因为在链1\u003c-2\u003c-5中，A并没有使用两次，检测是否是”双花“时是不会检查其他链上的交易情况的。下图中5写到2的后面的情况显然是不被希望的。 因此在比特币协议中，规定写在**最长合法链**之后的才是合法区块,上述例子称为”forking attack（分叉攻击）“，即：通过往区块链中间某个区块后插入区块实现回滚某个已经发生了的交易。 在正常情况下，如果两个节点同时找到了合适的nonce并发布出去，由于整个系统中节点众多，不同节点认同的这两个区块中的某一个，那么就会形成两个等长的链，按照最长合法链原则，这两个都是合法的，比特币系统中，接受某个区块就会往该区块后面继续添加区块，因此会存在临时的分支，但某条链最后会”胜出“。 如上图，5，6同时发布，原先最长链分叉，这时形成两条合法链，如果在下一时刻，区块5后增加区块7，而6后并未增加新的区块，那么6所在的那条链就会被丢弃，称为”orphan block“。在”orphan block“中获得的block reward是不会被认可的 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:3:3","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#最长合法链"},{"categories":["distributed"],"content":"\rblock reward（出块奖励）去中心化货币面临的两个问题：①谁来发行货币；②怎么保证交易的合法性 coinbase transaction是发行比特币的唯一方法。 前21万个区块里，每个区块发行50BTC，之后21万区块里，每个区块发行25BTC，下一21万区块中，每个区块发行12.5BTC 50BTC -\u003e 25BTC -\u003e 12.5BTC -\u003e …… **hash rate：**比特币系统中根据算力投票，不同区块获取符合nonce的概率是不同的，这个称为hash rate 针对“sybil attack”，由于投票权是以算力决定的，即使创建账户十分多，也无法改变其算力大小。 区块链技术与应用——BTC的共识协议 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:3:4","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#block-reward出块奖励"},{"categories":["distributed"],"content":"\rBTH-实现比特币采用的是基于交易的账本模式，transaction-based ledger。 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:4:0","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#bth-实现"},{"categories":["distributed"],"content":"\rUTXO：Unspend Transaction Output即：还没有被花出去的交易的输出，区块链上有很多交易，有些交易的输出可能已经被花掉了，有些还没有被花掉，没有被花掉的交易的输出组成的集合就是UTXO。UTXO为比特币系统中的一个数据结构。 例如：A转给B、C各5BTC，这时B将这5个比特币花掉了，C没有花掉，那么就只有A与C的输出在UTXO中 如果这时B再转给D，D也没有花掉，那么B转给D的输出就会保存在UTXO UTXO中的每个元素要给出产生这个输出的交易的hash值，以及它在这个交易里是第几个输出，就可以定位到UTXO中的输出 为什么要维护UTXO这个数据结构？ 花掉的币只有在UTXO这个集合中才是合法的，如果不在这个集合中，那么花的币要么不存在，要么以前已经被花过了。全节点要在内存中维护UTXO这个数据结构，以便快速检测“double spending” total inputs=total outputs：一笔交易可以有多个输入（不一定来自同一个地址，所以一个交易也可能有多个签名），也可以有多个输出，要求交易的总输入等于总输出。 但有时total inputs 可能稍微大于outputs，因为还要给打包区块的节点提供费用，即$transaction\\quad fee（交易费）$。一般交易费是比较小的，甚至有的交易没有交易费。 为什么有交易费？ 光有出块奖励机制还不够，有些“自私”的节点可能只去打包自己的交易，而不去管别人的交易，因为打包别人的交易还要验证交易的合法性，占用带宽等，，显然只打包自己的会方便很多，因此交易会提供费用给打包的人。 目前挖矿主要还是为了获得出块奖励，规定约10min出一个区块，出21万个区块就减半，因此出块奖励大约4年就减半。在很长时间之后出块奖励会变得非常小，那么交易费就会成主要奖励来源了 $$ T_{减半周期}=\\frac {21000010min}{60min24h*365d}=3.995433 $$ 与比特币这种$transaction-based\\quad ledger$相对应的还有一种$account-based(基于账户的)\\quad ledger$,以太坊就是用的此模式，这种模式下，系统显示记录每个账户上有多少个币。两种方式各有优缺点，前者显然隐私的保护会更好，但是代价就是要说明币的来源。 创建时间：2020-11-04 修改时间：2020-11-08 ","date":"2020-11-04","objectID":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/:4:1","series":null,"tags":["block chain","distributed system","encryption"],"title":"区块链与安全Note","uri":"/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%AE%89%E5%85%A8note/#utxounspend-transaction-output"}]